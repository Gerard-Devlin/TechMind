<h1>
    排列
</h1>

[TOC]

---

## 一、`next-permutation`函数应用

```c++
#include<bits/stdc++.h>
using namespace std;
int a[100]={1,2,3,4,};
int main(){
    do{
        for(int i=0;i<4;i++){
            cout<<a[i]<<" ";
        }
        cout<<endl;
    }while(next_permutation(a,a+4));
}
/*函数功能：
    将当前序列重排为下一个字典序的排列
    如果存在下一个排列，返回true
    如果当前已是最后一个排列，返回false并重排为最小排列
    如果要生成所有排列，初始序列必须是最小的排列（升序排列）
 */
```

---

## 例题

### e.g.16 # [NOIP2004 普及组] 火星人

题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三进制数 | 代表的数字 |
| :------: | :--------: |
|  $123$   |    $1$     |
|  $132$   |    $2$     |
|  $213$   |    $3$     |
|  $231$   |    $4$     |
|  $312$   |    $5$     |
|  $321$   |    $6$     |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。

输入格式

共三行。  
第一行一个正整数 $N$，表示火星人手指的数目（$1 \le N \le 10000$）。  
第二行是一个正整数 $M$，表示要加上去的小整数（$1  \le  M  \le  100$）。  
下一行是 $1$ 到 $N$ 这 $N$ 个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。

输出格式

$N$ 个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。

样例 

样例输入 

```
5
3
1 2 3 4 5
```

样例输出 

```
1 2 4 5 3
```

提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    int N;
    int M;
    cin >> N >> M;
    int arr[N];
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }
    //写入，然后next_permutation至M次   
    for (int i = 0; i < M; i++) {
        next_permutation(arr, arr + N);
    }
    for (int i = 0; i < N; i++) {
        cout << arr[i] << " ";
    }
}

```

---

### e.g.17 [NOIP2002 普及组] 选数

题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

输入格式

第一行两个空格隔开的整数 $n,k$（$1 \le n \le 20$，$k<n$）。

第二行 $n$ 个整数，分别为 $x_1,x_2,\cdots,x_n$（$1 \le x_i \le 5\times 10^6$）。

输出格式

输出一个整数，表示种类数。

样例 

样例输入 

```
4 3
3 7 12 19
```

样例输出 

```
1
```

提示

**【题目来源】**

NOIP 2002 普及组第二题

```c++
#include <bits/stdc++.h>
using namespace std;
int a[100];
int b[100];
bool isPrime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) return false;
    }
    return true;
}


int main() {
    int n, k;
    cin >> n >> k;
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = n; i >= n - k + 1; i--) {
        b[i] = 1;
    }
    do {
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            if (b[i] == 1) {
                sum += a[i];
            }
            
        }
        if (isPrime(sum)) {
                ans++;
            }
    }while(next_permutation(b + 1, b + n + 1));
    cout << ans;
}
```

---