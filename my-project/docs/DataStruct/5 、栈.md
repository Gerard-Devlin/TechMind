[TOC]

---

## 1ã€å®šä¹‰

![stack.svg](../assets/images/DataStruct/stack.svg)

!!! tip
      LIFOï¼ˆLast In First Outï¼‰ï¼šğŸ§  **â€œåªèƒ½è®¿é—®æœ€ä¸Šé¢é‚£ä¸€ä¸ª**

| æ“ä½œ | $O(1)$                                   |
| ------------ | ---------------------------------------- |
| (1)`Push`    | å…¥æ ˆ                    |
| (2)`Pop`     |å‡ºæ ˆ|
| (3)`Top`     |è¿”å›æ ˆé¡¶å€¼|
| (4)`IsEmpty` | è¿”å›True/False                     |

??? info 
    - é€’å½’è°ƒç”¨å‡½æ•°
    - ç¼–è¾‘å™¨æ’¤é”€
    - æ‹¬å·åŒ¹é…
    - ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢

---

## 2ã€å®ç°

### ï¼ˆ1ï¼‰é¡ºåºæ ˆ

```
int A[10];
top â† -1;       // æ ˆä¸ºç©ºæ—¶ top åˆå§‹ä¸º -1,è¡¨ç¤ºç©ºæ ˆ

Push(x) {
    top â† top + 1;
    A[top] â† x;
}

Pop() {
    top â† top - 1;
}

Top() {
	return A[top];
}

IsEmpty() {
	if (top == -1) return true;
	else return false;
}
```

!!! warning
	- ä¸èƒ½å‡ºç°æº¢å‡ºçš„æƒ…å†µ

    - | æ“ä½œ           | æ—¶é—´å¤æ‚åº¦     |
      | -------------- | -------------- |
      | Push           | $O(1)$ - Best  |
      |                | $O(n)$ - Worst |
      |                | $O(1)$ - Avg   |
      | n æ¬¡ Push æ“ä½œ | $O(n)$         |

```c++
#define MAX_SIZE 101
int A[MAX_SIZE];
int top = -1;
void Push(int x) {
    if (top == MAX_SIZE - 1) {
        printf("Stack Overflow\n");
    }
    A[++top] = x;
}
void Pop() {
    if (top == -1) {
        printf("Stack Underflow\n");
    }
    top--;
}
int Top() {
    return A[top];
}

void Print() {
    int i;
    printf("Stack:\n");
    for (i = top; i >= 0; i--) {
        printf("%d\n", A[i]);
    }
    printf("\n");
}

int main() {
    Push(2);
    Print();
    Push(5);
    Print();
    Push(10);
    Print();
    Pop();
    Print();
    Push(12);
    Print();
}
```

---

### ï¼ˆ2ï¼‰é“¾æ ˆ

- æ’å…¥/åˆ é™¤
      - å°¾æ’â€“ $O(n)$
      - å¤´æ’â€“ $O(1)$

```c++
struct Node {
    int data;
    Node *link;
};

struct Node *top = NULL; 

void Push(int x) {
    Node *temp = new Node;
    temp->data = x;
    temp->link = top;
    top = temp;
}

void Pop() {
    Node *temp;
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    temp = top;
    top = top->link; 
    delete temp;    
}

void Top() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    printf("%d\n", top->data);
}

void IsEmpty() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    } else {
        printf("Stack is not empty\n");
    }
}

void Print() {
    Node *temp = top;
    printf("Stack is : ");
    while (temp != NULL) { 
        printf("%d ", temp->data);
        temp = temp->link;
    }
    printf("\n");
}

int main() {
    Push(5);Print();IsEmpty();
    Pop();Print();IsEmpty();
    Push(6);Print();IsEmpty();
    Push(7);Print();IsEmpty();
    Push(8);Print();IsEmpty();
    return 0;
}
```

!!! note
	ä¸ç”¨æ‹…å¿ƒæ ˆæº¢å‡ºï¼›å†…å­˜åªåœ¨éœ€è¦æ—¶ä½¿ç”¨

---

## 3ã€åè½¬

### ï¼ˆ1ï¼‰åè½¬å­—ç¬¦ä¸²

```C++
#include<bits/stdc++.h>
using namespace std;

void Reverse(char C[],int n) {
    stack<char> S;  // åˆ›å»ºä¸€ä¸ªæ ˆï¼ˆåè¿›å…ˆå‡ºï¼‰

    // å°†å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ä¾æ¬¡å‹æ ˆ
    for(int i=0;i<n;i++) {
        S.push(C[i]);
    }

    // å†æŠŠå­—ç¬¦ä¾æ¬¡ä»æ ˆä¸­å¼¹å‡ºï¼Œè¦†ç›–åŸå­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦
    for(int i=0;i<n;i++) {
        C[i]=S.top();  // æ‹¿åˆ°æ ˆé¡¶å…ƒç´ 
        S.pop();       // å¼¹å‡ºæ ˆé¡¶
    }
}


int main() {
    char C[51];
    cout << "Enter a string: ";
    cin.getline(C, 51);  // å®‰å…¨è¯»å…¥ï¼ˆæœ€å¤š50ä¸ªå­—ç¬¦ï¼‰
    
    Reverse(C, strlen(C));
    
    cout << "Output is: " << C << endl;
    return 0;
}
```

!!! note
	æ—¶é—´/ç©ºé—´å¤æ‚åº¦éƒ½æ˜¯ï¼š$O(n)$

---

### ï¼ˆ2ï¼‰åè½¬é“¾è¡¨

|            | æ˜¾å¼æ ˆï¼ˆè¿­ä»£ï¼‰ | éšå¼æ ˆï¼ˆè¿­ä»£ï¼‰ |
| ---------- | -------------- | -------------- |
| æ—¶é—´å¤æ‚åº¦ | $O(n)$         | $O(n)$         |
| ç©ºé—´å¤æ‚åº¦ | $O(1)$         | $O(n)$         |

```c++
void Reverse() {
    if (head == NULL) return;  // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œç›´æ¥è¿”å›

    stack<Node*> S;            // åˆ›å»ºä¸€ä¸ªæ ˆï¼Œç”¨äºæš‚å­˜èŠ‚ç‚¹åœ°å€
    Node* temp = head;         // ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†

    // Step 1: éå†é“¾è¡¨ï¼Œå°†æ‰€æœ‰èŠ‚ç‚¹æŒ‡é’ˆå‹å…¥æ ˆä¸­
    while (temp != NULL) {
        S.push(temp);          // æŠŠå½“å‰èŠ‚ç‚¹åœ°å€å‹å…¥æ ˆ
        temp = temp->next;     // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    }

    // Step 2: å°†æ ˆé¡¶å…ƒç´ ï¼ˆåŸé“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰è®¾ä¸ºæ–°çš„å¤´èŠ‚ç‚¹
    Node* temp2 = S.top();     // è·å–æ ˆé¡¶ï¼ˆæœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰
    head = temp2;              // æ›´æ–° head æŒ‡é’ˆ
    S.pop();                   // å¼¹å‡ºè¿™ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºå®ƒå·²ç»è®¾ç½®ä¸ºæ–°å¤´èŠ‚ç‚¹

    // Step 3: ä¾æ¬¡å¼¹å‡ºå‰©ä½™èŠ‚ç‚¹ï¼Œé‡æ–°è¿æ¥ next æŒ‡é’ˆ
    while (!S.empty()) {
        temp2->next = S.top(); // æŠŠå½“å‰èŠ‚ç‚¹çš„ next æŒ‡å‘ä¸‹ä¸€ä¸ªå‡ºæ ˆçš„èŠ‚ç‚¹
        S.pop();               // å¼¹å‡ºè¯¥èŠ‚ç‚¹
        temp2 = temp2->next;   // ç§»åŠ¨åˆ°åˆšè®¾ç½®çš„ next èŠ‚ç‚¹ä¸Šï¼Œå‡†å¤‡ç»§ç»­è¿æ¥
    }

    // Step 4: æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„ next åº”è¯¥æ˜¯ NULLï¼ˆå¦åˆ™ä¼šå½¢æˆç¯ï¼‰
    temp2->next = NULL;
}
```

---

## 4ã€åº”ç”¨

### ï¼ˆ1ï¼‰æ‹¬å·åŒ¹é…

- ä»å·¦åˆ°å³æ‰«æå­—ç¬¦ä¸²
- é‡åˆ°å¼€æ‹¬å·`(`, `[`, `{`å°±å‹å…¥æ ˆ
- é‡åˆ°é—­æ‹¬å·`)`, `]`, `}`å°±ä»æ ˆä¸­å¼¹å‡ºä¸€ä¸ªå¼€æ‹¬å·ï¼Œæ£€æŸ¥æ˜¯å¦åŒ¹é…
- æœ€ç»ˆæ ˆåº”ä¸ºç©ºï¼ˆå³æ‰€æœ‰æ‹¬å·éƒ½æ­£ç¡®åŒ¹é…ï¼‰

```F#
Check for balanced Parentheses(exp){
	nâ†length(exp)
	Create a stack S;
	for i from 0 to n-1{
		if (exp[i] is "(" or"[" or "{"){
			Push(exp[i])
			}else if(exp[i] is ")" or"]" or "}")
				if(S is empty){
					return false;
				}else{
					Pop()
				}
			}
			
	}
}
if S is empty true
else:  false
```

```C++
#include <string.h>
#include <stdbool.h>

bool CheckforParentheses(char* expression) {
    int n = strlen(expression);
    char S[100];
    int top = -1;// Stack to store the parentheses

    for (int i = 0; i < n; i++) {
        if (expression[i] == '(' ||
            expression[i] == '[' ||
            expression[i] == '{'    ) {
            S[++top] = expression[i];
            } else if (expression[i] == ')' ||
                       expression[i] == ']'||
                       expression[i]=='}') {
                if (top == -1) {
                    return false;
                } if (
                    (expression[i] == ')' && S[top] == '(') ||
                    (expression[i] == ']' && S[top] == '[') ||
                    (expression[i] == '}' && S[top] == '{')) {
                    top--;
                    }else {
                        return false;
                    }
                       }
    }
    return top==-1;//return true if all parentheses are matched
}

int main() {
    char expression[100];
    printf("Enter an expression: ");
    fgets(expression, sizeof(expression), stdin);
    expression[strcspn(expression, "\n")] = '\0'; //Remove \n from string
    CheckforParentheses(expression);
    if (CheckforParentheses(expression)) {
        printf(" The expression is valid\n");
    } else {
        printf("The expression is invalid\n");
    }
    return 0;
}
```

---

### ï¼ˆ2ï¼‰ä¸­ç¼€è½¬åç¼€

## 1ï¼‰Intro

### â‘ Infix
![Infix.png](../assets/images/DataStruct/Infix.png)
### â‘¡Prefix
![Prefix.png](../assets/images/DataStruct/Prefix.png)
### â‘¢Postfix
![Postfix.png](../assets/images/DataStruct/Postfix.png)

---
![exFix.png](../assets/images/DataStruct/exFix.png)

---

## 2ï¼‰Evaluation of  Prefix and Postfix expressions

![evaluate.png](../assets/images/DataStruct/evaluate.png)

!!! success
      >
      > Postfixï¼š
      >
      > - Look for pattern `<num><num><operator>`(from left to right)
      >
      >   - ![RtoL.png](../assets/images/DataStruct/RtoL.png)
      >
      ```c++
      //Sudo code
      EvaluatePostfix(exp){
         create a stack S;
         for i to lenngth(exp)-1{
             if(exp[i] is operand){
                 Push(exp[i])
             }else if(exp[i] is operator){
                 op2 Pop;
                 op1 Pop;
                 res=Preform(exp[i],op1,op2);
                 Push(res)
             }
         }
         return top of stack
      }
      ```
      >
      > Prefixï¼š
      >
      > - Look for pattern `<num><num><operator>`
      >   - Difference from Postfix: **scan from right to left**

---

## 3ï¼‰Infix to Postfix

```c++
//Sudo code
InfixToPostfix(exp){
    create a stack s;
    res->empty string;
    for i from 0 to length (exp)-1{
        if exp[i] is operand {
            res<-res+exp[i];
        }
        else if exp[i] is operator{
            while(!=s.empty()&&HasHigherPrec(s.top(),exp[i])){
                res<-res+s.top();
                s.Pop()
            }
            s.Push(exp[i]);
        }
        while(!s.empty()){
            res<-res+s.top();
            s.pop();
        }
    }
    return res;
}
```

