[TOC]

---

## 1、定义

![stack.svg](../assets/images/DataStruct/stack.svg)

!!! tip
      LIFO（Last In First Out）：**“只能访问最上面那一个**

| 操作 | $O(1)$                                   |
| ------------ | ---------------------------------------- |
| (1)`Push`    | 入栈                    |
| (2)`Pop`     |出栈|
| (3)`Top`     |返回栈顶值|
| (4)`IsEmpty` | 返回True/False                     |

??? info 
    - 递归调用函数
    - 编辑器撤销
    - 括号匹配
    - 中缀表达式转换

---

## 2、实现

### （1）顺序栈

```
int A[10];
top ← -1;       // 栈为空时 top 初始为 -1,表示空栈

Push(x) {
    top ← top + 1;
    A[top] ← x;
}

Pop() {
    top ← top - 1;
}

Top() {
	return A[top];
}

IsEmpty() {
	if (top == -1) return true;
	else return false;
}
```

!!! warning
	- 不能出现溢出的情况

    - | 操作           | 时间复杂度     |
      | -------------- | -------------- |
      | Push           | $O(1)$ - Best  |
      |                | $O(n)$ - Worst |
      |                | $O(1)$ - Avg   |
      | n 次 Push 操作 | $O(n)$         |

```c++
#define MAX_SIZE 101
int A[MAX_SIZE];
int top = -1;
void Push(int x) {
    if (top == MAX_SIZE - 1) {
        printf("Stack Overflow\n");
    }
    A[++top] = x;
}
void Pop() {
    if (top == -1) {
        printf("Stack Underflow\n");
    }
    top--;
}
int Top() {
    return A[top];
}

void Print() {
    int i;
    printf("Stack:\n");
    for (i = top; i >= 0; i--) {
        printf("%d\n", A[i]);
    }
    printf("\n");
}

int main() {
    Push(2);
    Print();
    Push(5);
    Print();
    Push(10);
    Print();
    Pop();
    Print();
    Push(12);
    Print();
}
```

---

### （2）链栈

- 插入/删除
      - 尾插– $O(n)$
      - 头插– $O(1)$

```c++
struct Node {
    int data;
    Node *link;
};

struct Node *top = NULL; 

void Push(int x) {
    Node *temp = new Node;
    temp->data = x;
    temp->link = top;
    top = temp;
}

void Pop() {
    Node *temp;
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    temp = top;
    top = top->link; 
    delete temp;    
}

void Top() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    printf("%d\n", top->data);
}

void IsEmpty() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    } else {
        printf("Stack is not empty\n");
    }
}

void Print() {
    Node *temp = top;
    printf("Stack is : ");
    while (temp != NULL) { 
        printf("%d ", temp->data);
        temp = temp->link;
    }
    printf("\n");
}

int main() {
    Push(5);Print();IsEmpty();
    Pop();Print();IsEmpty();
    Push(6);Print();IsEmpty();
    Push(7);Print();IsEmpty();
    Push(8);Print();IsEmpty();
    return 0;
}
```

!!! note
	不用担心栈溢出；内存只在需要时使用

---

## 3、反转

### （1）反转字符串

```C++
#include<bits/stdc++.h>
using namespace std;

void Reverse(char C[],int n) {
    stack<char> S;  // 创建一个栈（后进先出）

    // 将字符串中的字符依次压栈
    for(int i=0;i<n;i++) {
        S.push(C[i]);
    }

    // 再把字符依次从栈中弹出，覆盖原字符串中的字符
    for(int i=0;i<n;i++) {
        C[i]=S.top();  // 拿到栈顶元素
        S.pop();       // 弹出栈顶
    }
}


int main() {
    char C[51];
    cout << "Enter a string: ";
    cin.getline(C, 51);  // 安全读入（最多50个字符）
    
    Reverse(C, strlen(C));
    
    cout << "Output is: " << C << endl;
    return 0;
}
```

!!! note
	时间/空间复杂度都是：$O(n)$

---

### （2）反转链表

|            | 显式栈（迭代） | 隐式栈（迭代） |
| ---------- | -------------- | -------------- |
| 时间复杂度 | $O(n)$         | $O(n)$         |
| 空间复杂度 | $O(1)$         | $O(n)$         |

```c++
void Reverse() {
    if (head == NULL) return;  // 如果链表为空，直接返回

    stack<Node*> S;            // 创建一个栈，用于暂存节点地址
    Node* temp = head;         // 从头节点开始遍历

    // Step 1: 遍历链表，将所有节点指针压入栈中
    while (temp != NULL) {
        S.push(temp);          // 把当前节点地址压入栈
        temp = temp->next;     // 移动到下一个节点
    }

    // Step 2: 将栈顶元素（原链表的最后一个节点）设为新的头节点
    Node* temp2 = S.top();     // 获取栈顶（最后一个节点）
    head = temp2;              // 更新 head 指针
    S.pop();                   // 弹出这个节点，因为它已经设置为新头节点

    // Step 3: 依次弹出剩余节点，重新连接 next 指针
    while (!S.empty()) {
        temp2->next = S.top(); // 把当前节点的 next 指向下一个出栈的节点
        S.pop();               // 弹出该节点
        temp2 = temp2->next;   // 移动到刚设置的 next 节点上，准备继续连接
    }

    // Step 4: 最后一个节点的 next 应该是 NULL（否则会形成环）
    temp2->next = NULL;
}
```

---

## 4、应用

### （1）括号匹配

- 从左到右扫描字符串
- 遇到开括号`(`, `[`, `{`就压入栈
- 遇到闭括号`)`, `]`, `}`就从栈中弹出一个开括号，检查是否匹配
- 最终栈应为空（即所有括号都正确匹配）

```c++
Function CheckBalancedParentheses(exp):
    n ← length(exp)
    Create an empty stack S

    for i from 0 to n-1:
        if exp[i] is '(' or '[' or '{':
            S.Push(exp[i])  // 将开括号入栈

        else if exp[i] is ')' or ']' or '}':
            if S is empty:
                return false  // 没有对应的开括号，错误

            top ← S.Top()     // 查看栈顶元素
            if exp[i] and top 不匹配:
                return false  // 括号不成对，错误

            S.Pop()           // 匹配成功，弹出栈顶开括号

    // 所有字符处理完成后，栈应为空
    if S is empty:
        return true
    else:
        return false
```

```C++
bool CheckforParentheses(char* expression) {
    int n = strlen(expression);
    char S[100];       // 栈数组，最多存 100 个括号
    int top = -1;      // 栈顶指针，初始为 -1 表示空栈

    for (int i = 0; i < n; i++) {
        // 如果是开括号，压入栈中
        if (expression[i] == '(' || expression[i] == '[' || expression[i] == '{') {
            S[++top] = expression[i];
        } 
        // 如果是闭括号
        else if (expression[i] == ')' || expression[i] == ']' || expression[i] == '}') {
            if (top == -1) {
                return false;  // 栈空，说明没有匹配的开括号
            }
            // 判断是否与栈顶开括号匹配
            if ((expression[i] == ')' && S[top] == '(') ||
                (expression[i] == ']' && S[top] == '[') ||
                (expression[i] == '}' && S[top] == '{')) {
                top--; // 匹配成功，弹出栈顶
            } else {
                return false;  // 匹配失败
            }
        }
        // 非括号字符可忽略或按需处理
    }
    return top == -1; // 栈空说明全部匹配成功
}


int main() {
    char expression[100];
    printf("Enter an expression: ");
    fgets(expression, sizeof(expression), stdin); // 从输入读取字符串
    expression[strcspn(expression, "\n")] = '\0'; // 删除末尾的换行符

    // 调用检查函数并输出结果
    if (CheckforParentheses(expression)) {
        printf("The expression is valid\n");
    } else {
        printf("The expression is invalid\n");
    }
    return 0;
}
```

---

### （2）中缀转后缀

| 表达式类型          | 格式                             | 示例    | 特点与说明                                                   |
| ------------------- | -------------------------------- | ------- | ------------------------------------------------------------ |
| **Infix（中缀）**   | `<operand> <operator> <operand>` | `A + B` | 最常见的书写方式；需要括号或操作符优先级规则来解析运算顺序   |
| **Postfix（后缀）** | `<operand> <operand> <operator>` | `A B +` | 又称逆波兰表达法；不需要括号；从左到右，遇到运算符立即处理前两个操作数 |
| **Prefix（前缀）**  | `<operator> <operand> <operand>` | `+ A B` | 又称波兰表达法；也不需要括号；递归或从右到左处理；适合用栈或递归实现 |

!!! success
    📌Postfix 表达式处理规则：

    - **识别模式**：从左到右扫描，寻找 `<num><num><operator>` 的结构
    
      - **操作步骤**：
    
        1. 遇到数字（操作数）就 **压入栈中**
    
        2. 遇到操作符（如 `+`, `-`, `*`, `/`）时，从栈中 **弹出两个数**
    
           - 注意顺序：先弹出的是第二个操作数，后弹出的是第一个操作数
    
        3. 计算结果后，将结果 **压回栈中**
    
      - **最终结果**：扫描完毕后，栈中剩下的最后一个元素即为最终结果

```c++
// 计算postfix表达式
EvaluatePostfix(exp) {
    create a stack S;

    for i from 0 to length(exp) - 1 {
        if (exp[i] is an operand) {
            Push(exp[i])  // 操作数压栈
        }
        else if (exp[i] is an operator) {
            op2 = Pop();  // 注意：先弹出的是右操作数
            op1 = Pop();  // 然后是左操作数
            result = Perform(exp[i], op1, op2); // 执行 op1 exp[i] op2
            Push(result); // 结果压栈
        }
    }

    return Top of stack; // 栈顶即为表达式最终值
}

```

```c++
// 中缀转后缀
InfixToPostfix(exp) {
    create a stack S;           // 存储操作符
    result ← empty string;      // 存储输出的后缀表达式

    for i from 0 to length(exp) - 1 {
        if exp[i] is operand {
            result ← result + exp[i];  // 直接添加到结果
        }
        else if exp[i] is operator {
            while (!S.empty() && HasHigherPrec(S.top(), exp[i])) {
                result ← result + S.top();
                S.pop();
            }
            S.push(exp[i]);  // 当前运算符入栈
        }
    }

    // 处理剩余栈中的运算符
    while (!S.empty()) {
        result ← result + S.top();
        S.pop();
    }

    return result;
}

```

---

