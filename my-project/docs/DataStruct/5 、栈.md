[TOC]

---

## 1ã€å®šä¹‰

![stack.svg](../assets/images/DataStruct/stack.svg)

!!! tip
      LIFOï¼ˆLast In First Outï¼‰ï¼š**â€œåªèƒ½è®¿é—®æœ€ä¸Šé¢é‚£ä¸€ä¸ª**

| æ“ä½œ | $O(1)$                                   |
| ------------ | ---------------------------------------- |
| (1)`Push`    | å…¥æ ˆ                    |
| (2)`Pop`     |å‡ºæ ˆ|
| (3)`Top`     |è¿”å›æ ˆé¡¶å€¼|
| (4)`IsEmpty` | è¿”å›True/False                     |

??? info 
    - é€’å½’è°ƒç”¨å‡½æ•°
    - ç¼–è¾‘å™¨æ’¤é”€
    - æ‹¬å·åŒ¹é…
    - ä¸­ç¼€è¡¨è¾¾å¼è½¬æ¢

---

## 2ã€å®ç°

### ï¼ˆ1ï¼‰é¡ºåºæ ˆ

```
int A[10];
top â† -1;       // æ ˆä¸ºç©ºæ—¶ top åˆå§‹ä¸º -1,è¡¨ç¤ºç©ºæ ˆ

Push(x) {
    top â† top + 1;
    A[top] â† x;
}

Pop() {
    top â† top - 1;
}

Top() {
	return A[top];
}

IsEmpty() {
	if (top == -1) return true;
	else return false;
}
```

!!! warning
	- ä¸èƒ½å‡ºç°æº¢å‡ºçš„æƒ…å†µ

    - | æ“ä½œ           | æ—¶é—´å¤æ‚åº¦     |
      | -------------- | -------------- |
      | Push           | $O(1)$ - Best  |
      |                | $O(n)$ - Worst |
      |                | $O(1)$ - Avg   |
      | n æ¬¡ Push æ“ä½œ | $O(n)$         |

```c++
#define MAX_SIZE 101
int A[MAX_SIZE];
int top = -1;
void Push(int x) {
    if (top == MAX_SIZE - 1) {
        printf("Stack Overflow\n");
    }
    A[++top] = x;
}
void Pop() {
    if (top == -1) {
        printf("Stack Underflow\n");
    }
    top--;
}
int Top() {
    return A[top];
}

void Print() {
    int i;
    printf("Stack:\n");
    for (i = top; i >= 0; i--) {
        printf("%d\n", A[i]);
    }
    printf("\n");
}

int main() {
    Push(2);
    Print();
    Push(5);
    Print();
    Push(10);
    Print();
    Pop();
    Print();
    Push(12);
    Print();
}
```

---

### ï¼ˆ2ï¼‰é“¾æ ˆ

- æ’å…¥/åˆ é™¤
      - å°¾æ’â€“ $O(n)$
      - å¤´æ’â€“ $O(1)$

```c++
struct Node {
    int data;
    Node *link;
};

struct Node *top = NULL; 

void Push(int x) {
    Node *temp = new Node;
    temp->data = x;
    temp->link = top;
    top = temp;
}

void Pop() {
    Node *temp;
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    temp = top;
    top = top->link; 
    delete temp;    
}

void Top() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    printf("%d\n", top->data);
}

void IsEmpty() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    } else {
        printf("Stack is not empty\n");
    }
}

void Print() {
    Node *temp = top;
    printf("Stack is : ");
    while (temp != NULL) { 
        printf("%d ", temp->data);
        temp = temp->link;
    }
    printf("\n");
}

int main() {
    Push(5);Print();IsEmpty();
    Pop();Print();IsEmpty();
    Push(6);Print();IsEmpty();
    Push(7);Print();IsEmpty();
    Push(8);Print();IsEmpty();
    return 0;
}
```

!!! note
	ä¸ç”¨æ‹…å¿ƒæ ˆæº¢å‡ºï¼›å†…å­˜åªåœ¨éœ€è¦æ—¶ä½¿ç”¨

---

## 3ã€åè½¬

### ï¼ˆ1ï¼‰åè½¬å­—ç¬¦ä¸²

```C++
#include<bits/stdc++.h>
using namespace std;

void Reverse(char C[],int n) {
    stack<char> S;  // åˆ›å»ºä¸€ä¸ªæ ˆï¼ˆåè¿›å…ˆå‡ºï¼‰

    // å°†å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ä¾æ¬¡å‹æ ˆ
    for(int i=0;i<n;i++) {
        S.push(C[i]);
    }

    // å†æŠŠå­—ç¬¦ä¾æ¬¡ä»æ ˆä¸­å¼¹å‡ºï¼Œè¦†ç›–åŸå­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦
    for(int i=0;i<n;i++) {
        C[i]=S.top();  // æ‹¿åˆ°æ ˆé¡¶å…ƒç´ 
        S.pop();       // å¼¹å‡ºæ ˆé¡¶
    }
}


int main() {
    char C[51];
    cout << "Enter a string: ";
    cin.getline(C, 51);  // å®‰å…¨è¯»å…¥ï¼ˆæœ€å¤š50ä¸ªå­—ç¬¦ï¼‰
    
    Reverse(C, strlen(C));
    
    cout << "Output is: " << C << endl;
    return 0;
}
```

!!! note
	æ—¶é—´/ç©ºé—´å¤æ‚åº¦éƒ½æ˜¯ï¼š$O(n)$

---

### ï¼ˆ2ï¼‰åè½¬é“¾è¡¨

|            | æ˜¾å¼æ ˆï¼ˆè¿­ä»£ï¼‰ | éšå¼æ ˆï¼ˆè¿­ä»£ï¼‰ |
| ---------- | -------------- | -------------- |
| æ—¶é—´å¤æ‚åº¦ | $O(n)$         | $O(n)$         |
| ç©ºé—´å¤æ‚åº¦ | $O(1)$         | $O(n)$         |

```c++
void Reverse() {
    if (head == NULL) return;  // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œç›´æ¥è¿”å›

    stack<Node*> S;            // åˆ›å»ºä¸€ä¸ªæ ˆï¼Œç”¨äºæš‚å­˜èŠ‚ç‚¹åœ°å€
    Node* temp = head;         // ä»å¤´èŠ‚ç‚¹å¼€å§‹éå†

    // Step 1: éå†é“¾è¡¨ï¼Œå°†æ‰€æœ‰èŠ‚ç‚¹æŒ‡é’ˆå‹å…¥æ ˆä¸­
    while (temp != NULL) {
        S.push(temp);          // æŠŠå½“å‰èŠ‚ç‚¹åœ°å€å‹å…¥æ ˆ
        temp = temp->next;     // ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
    }

    // Step 2: å°†æ ˆé¡¶å…ƒç´ ï¼ˆåŸé“¾è¡¨çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰è®¾ä¸ºæ–°çš„å¤´èŠ‚ç‚¹
    Node* temp2 = S.top();     // è·å–æ ˆé¡¶ï¼ˆæœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼‰
    head = temp2;              // æ›´æ–° head æŒ‡é’ˆ
    S.pop();                   // å¼¹å‡ºè¿™ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºå®ƒå·²ç»è®¾ç½®ä¸ºæ–°å¤´èŠ‚ç‚¹

    // Step 3: ä¾æ¬¡å¼¹å‡ºå‰©ä½™èŠ‚ç‚¹ï¼Œé‡æ–°è¿æ¥ next æŒ‡é’ˆ
    while (!S.empty()) {
        temp2->next = S.top(); // æŠŠå½“å‰èŠ‚ç‚¹çš„ next æŒ‡å‘ä¸‹ä¸€ä¸ªå‡ºæ ˆçš„èŠ‚ç‚¹
        S.pop();               // å¼¹å‡ºè¯¥èŠ‚ç‚¹
        temp2 = temp2->next;   // ç§»åŠ¨åˆ°åˆšè®¾ç½®çš„ next èŠ‚ç‚¹ä¸Šï¼Œå‡†å¤‡ç»§ç»­è¿æ¥
    }

    // Step 4: æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„ next åº”è¯¥æ˜¯ NULLï¼ˆå¦åˆ™ä¼šå½¢æˆç¯ï¼‰
    temp2->next = NULL;
}
```

---

## 4ã€åº”ç”¨

### ï¼ˆ1ï¼‰æ‹¬å·åŒ¹é…

- ä»å·¦åˆ°å³æ‰«æå­—ç¬¦ä¸²
- é‡åˆ°å¼€æ‹¬å·`(`, `[`, `{`å°±å‹å…¥æ ˆ
- é‡åˆ°é—­æ‹¬å·`)`, `]`, `}`å°±ä»æ ˆä¸­å¼¹å‡ºä¸€ä¸ªå¼€æ‹¬å·ï¼Œæ£€æŸ¥æ˜¯å¦åŒ¹é…
- æœ€ç»ˆæ ˆåº”ä¸ºç©ºï¼ˆå³æ‰€æœ‰æ‹¬å·éƒ½æ­£ç¡®åŒ¹é…ï¼‰

```c++
Function CheckBalancedParentheses(exp):
    n â† length(exp)
    Create an empty stack S

    for i from 0 to n-1:
        if exp[i] is '(' or '[' or '{':
            S.Push(exp[i])  // å°†å¼€æ‹¬å·å…¥æ ˆ

        else if exp[i] is ')' or ']' or '}':
            if S is empty:
                return false  // æ²¡æœ‰å¯¹åº”çš„å¼€æ‹¬å·ï¼Œé”™è¯¯

            top â† S.Top()     // æŸ¥çœ‹æ ˆé¡¶å…ƒç´ 
            if exp[i] and top ä¸åŒ¹é…:
                return false  // æ‹¬å·ä¸æˆå¯¹ï¼Œé”™è¯¯

            S.Pop()           // åŒ¹é…æˆåŠŸï¼Œå¼¹å‡ºæ ˆé¡¶å¼€æ‹¬å·

    // æ‰€æœ‰å­—ç¬¦å¤„ç†å®Œæˆåï¼Œæ ˆåº”ä¸ºç©º
    if S is empty:
        return true
    else:
        return false
```

```C++
bool CheckforParentheses(char* expression) {
    int n = strlen(expression);
    char S[100];       // æ ˆæ•°ç»„ï¼Œæœ€å¤šå­˜ 100 ä¸ªæ‹¬å·
    int top = -1;      // æ ˆé¡¶æŒ‡é’ˆï¼Œåˆå§‹ä¸º -1 è¡¨ç¤ºç©ºæ ˆ

    for (int i = 0; i < n; i++) {
        // å¦‚æœæ˜¯å¼€æ‹¬å·ï¼Œå‹å…¥æ ˆä¸­
        if (expression[i] == '(' || expression[i] == '[' || expression[i] == '{') {
            S[++top] = expression[i];
        } 
        // å¦‚æœæ˜¯é—­æ‹¬å·
        else if (expression[i] == ')' || expression[i] == ']' || expression[i] == '}') {
            if (top == -1) {
                return false;  // æ ˆç©ºï¼Œè¯´æ˜æ²¡æœ‰åŒ¹é…çš„å¼€æ‹¬å·
            }
            // åˆ¤æ–­æ˜¯å¦ä¸æ ˆé¡¶å¼€æ‹¬å·åŒ¹é…
            if ((expression[i] == ')' && S[top] == '(') ||
                (expression[i] == ']' && S[top] == '[') ||
                (expression[i] == '}' && S[top] == '{')) {
                top--; // åŒ¹é…æˆåŠŸï¼Œå¼¹å‡ºæ ˆé¡¶
            } else {
                return false;  // åŒ¹é…å¤±è´¥
            }
        }
        // éæ‹¬å·å­—ç¬¦å¯å¿½ç•¥æˆ–æŒ‰éœ€å¤„ç†
    }
    return top == -1; // æ ˆç©ºè¯´æ˜å…¨éƒ¨åŒ¹é…æˆåŠŸ
}


int main() {
    char expression[100];
    printf("Enter an expression: ");
    fgets(expression, sizeof(expression), stdin); // ä»è¾“å…¥è¯»å–å­—ç¬¦ä¸²
    expression[strcspn(expression, "\n")] = '\0'; // åˆ é™¤æœ«å°¾çš„æ¢è¡Œç¬¦

    // è°ƒç”¨æ£€æŸ¥å‡½æ•°å¹¶è¾“å‡ºç»“æœ
    if (CheckforParentheses(expression)) {
        printf("The expression is valid\n");
    } else {
        printf("The expression is invalid\n");
    }
    return 0;
}
```

---

### ï¼ˆ2ï¼‰ä¸­ç¼€è½¬åç¼€

| è¡¨è¾¾å¼ç±»å‹          | æ ¼å¼                             | ç¤ºä¾‹    | ç‰¹ç‚¹ä¸è¯´æ˜                                                   |
| ------------------- | -------------------------------- | ------- | ------------------------------------------------------------ |
| **Infixï¼ˆä¸­ç¼€ï¼‰**   | `<operand> <operator> <operand>` | `A + B` | æœ€å¸¸è§çš„ä¹¦å†™æ–¹å¼ï¼›éœ€è¦æ‹¬å·æˆ–æ“ä½œç¬¦ä¼˜å…ˆçº§è§„åˆ™æ¥è§£æè¿ç®—é¡ºåº   |
| **Postfixï¼ˆåç¼€ï¼‰** | `<operand> <operand> <operator>` | `A B +` | åˆç§°é€†æ³¢å…°è¡¨è¾¾æ³•ï¼›ä¸éœ€è¦æ‹¬å·ï¼›ä»å·¦åˆ°å³ï¼Œé‡åˆ°è¿ç®—ç¬¦ç«‹å³å¤„ç†å‰ä¸¤ä¸ªæ“ä½œæ•° |
| **Prefixï¼ˆå‰ç¼€ï¼‰**  | `<operator> <operand> <operand>` | `+ A B` | åˆç§°æ³¢å…°è¡¨è¾¾æ³•ï¼›ä¹Ÿä¸éœ€è¦æ‹¬å·ï¼›é€’å½’æˆ–ä»å³åˆ°å·¦å¤„ç†ï¼›é€‚åˆç”¨æ ˆæˆ–é€’å½’å®ç° |

!!! success
    ğŸ“ŒPostfix è¡¨è¾¾å¼å¤„ç†è§„åˆ™ï¼š

    - **è¯†åˆ«æ¨¡å¼**ï¼šä»å·¦åˆ°å³æ‰«æï¼Œå¯»æ‰¾ `<num><num><operator>` çš„ç»“æ„
    
      - **æ“ä½œæ­¥éª¤**ï¼š
    
        1. é‡åˆ°æ•°å­—ï¼ˆæ“ä½œæ•°ï¼‰å°± **å‹å…¥æ ˆä¸­**
    
        2. é‡åˆ°æ“ä½œç¬¦ï¼ˆå¦‚ `+`, `-`, `*`, `/`ï¼‰æ—¶ï¼Œä»æ ˆä¸­ **å¼¹å‡ºä¸¤ä¸ªæ•°**
    
           - æ³¨æ„é¡ºåºï¼šå…ˆå¼¹å‡ºçš„æ˜¯ç¬¬äºŒä¸ªæ“ä½œæ•°ï¼Œåå¼¹å‡ºçš„æ˜¯ç¬¬ä¸€ä¸ªæ“ä½œæ•°
    
        3. è®¡ç®—ç»“æœåï¼Œå°†ç»“æœ **å‹å›æ ˆä¸­**
    
      - **æœ€ç»ˆç»“æœ**ï¼šæ‰«æå®Œæ¯•åï¼Œæ ˆä¸­å‰©ä¸‹çš„æœ€åä¸€ä¸ªå…ƒç´ å³ä¸ºæœ€ç»ˆç»“æœ

```c++
// è®¡ç®—postfixè¡¨è¾¾å¼
EvaluatePostfix(exp) {
    create a stack S;

    for i from 0 to length(exp) - 1 {
        if (exp[i] is an operand) {
            Push(exp[i])  // æ“ä½œæ•°å‹æ ˆ
        }
        else if (exp[i] is an operator) {
            op2 = Pop();  // æ³¨æ„ï¼šå…ˆå¼¹å‡ºçš„æ˜¯å³æ“ä½œæ•°
            op1 = Pop();  // ç„¶åæ˜¯å·¦æ“ä½œæ•°
            result = Perform(exp[i], op1, op2); // æ‰§è¡Œ op1 exp[i] op2
            Push(result); // ç»“æœå‹æ ˆ
        }
    }

    return Top of stack; // æ ˆé¡¶å³ä¸ºè¡¨è¾¾å¼æœ€ç»ˆå€¼
}

```

```c++
// ä¸­ç¼€è½¬åç¼€
InfixToPostfix(exp) {
    create a stack S;           // å­˜å‚¨æ“ä½œç¬¦
    result â† empty string;      // å­˜å‚¨è¾“å‡ºçš„åç¼€è¡¨è¾¾å¼

    for i from 0 to length(exp) - 1 {
        if exp[i] is operand {
            result â† result + exp[i];  // ç›´æ¥æ·»åŠ åˆ°ç»“æœ
        }
        else if exp[i] is operator {
            while (!S.empty() && HasHigherPrec(S.top(), exp[i])) {
                result â† result + S.top();
                S.pop();
            }
            S.push(exp[i]);  // å½“å‰è¿ç®—ç¬¦å…¥æ ˆ
        }
    }

    // å¤„ç†å‰©ä½™æ ˆä¸­çš„è¿ç®—ç¬¦
    while (!S.empty()) {
        result â† result + S.top();
        S.pop();
    }

    return result;
}

```

---

