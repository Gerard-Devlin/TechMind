[TOC]

---

## 1、定义

![stack.svg](../assets/images/DataStruct/stack.svg)

!!! tip
      LIFO（Last In First Out）：🧠 **“只能访问最上面那一个**

| 操作 | $O(1)$                                   |
| ------------ | ---------------------------------------- |
| (1)`Push`    | 入栈                    |
| (2)`Pop`     |出栈|
| (3)`Top`     |返回栈顶值|
| (4)`IsEmpty` | 返回True/False                     |

??? info 
    - 递归调用函数
    - 编辑器撤销
    - 括号匹配
    - 中缀表达式转换

---

## 2、实现

### （1）顺序栈

```
int A[10];
top ← -1;       // 栈为空时 top 初始为 -1,表示空栈

Push(x) {
    top ← top + 1;
    A[top] ← x;
}

Pop() {
    top ← top - 1;
}

Top() {
	return A[top];
}

IsEmpty() {
	if (top == -1) return true;
	else return false;
}
```

!!! warning
	- 不能出现溢出的情况

    - | 操作           | 时间复杂度     |
      | -------------- | -------------- |
      | Push           | $O(1)$ - Best  |
      |                | $O(n)$ - Worst |
      |                | $O(1)$ - Avg   |
      | n 次 Push 操作 | $O(n)$         |

```c++
#define MAX_SIZE 101
int A[MAX_SIZE];
int top = -1;
void Push(int x) {
    if (top == MAX_SIZE - 1) {
        printf("Stack Overflow\n");
    }
    A[++top] = x;
}
void Pop() {
    if (top == -1) {
        printf("Stack Underflow\n");
    }
    top--;
}
int Top() {
    return A[top];
}

void Print() {
    int i;
    printf("Stack:\n");
    for (i = top; i >= 0; i--) {
        printf("%d\n", A[i]);
    }
    printf("\n");
}

int main() {
    Push(2);
    Print();
    Push(5);
    Print();
    Push(10);
    Print();
    Pop();
    Print();
    Push(12);
    Print();
}
```

---

### （2）链栈

- 插入/删除
      - 尾插– $O(n)$
      - 头插– $O(1)$

```c++
struct Node {
    int data;
    Node *link;
};

struct Node *top = NULL; 

void Push(int x) {
    Node *temp = new Node;
    temp->data = x;
    temp->link = top;
    top = temp;
}

void Pop() {
    Node *temp;
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    temp = top;
    top = top->link; 
    delete temp;    
}

void Top() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    }
    printf("%d\n", top->data);
}

void IsEmpty() {
    if (top == NULL) {
        printf("Stack is empty\n");
        return;
    } else {
        printf("Stack is not empty\n");
    }
}

void Print() {
    Node *temp = top;
    printf("Stack is : ");
    while (temp != NULL) { 
        printf("%d ", temp->data);
        temp = temp->link;
    }
    printf("\n");
}

int main() {
    Push(5);Print();IsEmpty();
    Pop();Print();IsEmpty();
    Push(6);Print();IsEmpty();
    Push(7);Print();IsEmpty();
    Push(8);Print();IsEmpty();
    return 0;
}
```

!!! note
	不用担心栈溢出；内存只在需要时使用

---

## 3、反转

### （1）反转字符串

```C++
#include<bits/stdc++.h>
using namespace std;

void Reverse(char C[],int n) {
    stack<char> S;  // 创建一个栈（后进先出）

    // 将字符串中的字符依次压栈
    for(int i=0;i<n;i++) {
        S.push(C[i]);
    }

    // 再把字符依次从栈中弹出，覆盖原字符串中的字符
    for(int i=0;i<n;i++) {
        C[i]=S.top();  // 拿到栈顶元素
        S.pop();       // 弹出栈顶
    }
}


int main() {
    char C[51];
    cout << "Enter a string: ";
    cin.getline(C, 51);  // 安全读入（最多50个字符）
    
    Reverse(C, strlen(C));
    
    cout << "Output is: " << C << endl;
    return 0;
}
```

!!! note
	时间/空间复杂度都是：$O(n)$

---

### （2）反转链表

|            | 显式栈（迭代） | 隐式栈（迭代） |
| ---------- | -------------- | -------------- |
| 时间复杂度 | $O(n)$         | $O(n)$         |
| 空间复杂度 | $O(1)$         | $O(n)$         |

```c++
void Reverse() {
    if (head == NULL) return;  // 如果链表为空，直接返回

    stack<Node*> S;            // 创建一个栈，用于暂存节点地址
    Node* temp = head;         // 从头节点开始遍历

    // Step 1: 遍历链表，将所有节点指针压入栈中
    while (temp != NULL) {
        S.push(temp);          // 把当前节点地址压入栈
        temp = temp->next;     // 移动到下一个节点
    }

    // Step 2: 将栈顶元素（原链表的最后一个节点）设为新的头节点
    Node* temp2 = S.top();     // 获取栈顶（最后一个节点）
    head = temp2;              // 更新 head 指针
    S.pop();                   // 弹出这个节点，因为它已经设置为新头节点

    // Step 3: 依次弹出剩余节点，重新连接 next 指针
    while (!S.empty()) {
        temp2->next = S.top(); // 把当前节点的 next 指向下一个出栈的节点
        S.pop();               // 弹出该节点
        temp2 = temp2->next;   // 移动到刚设置的 next 节点上，准备继续连接
    }

    // Step 4: 最后一个节点的 next 应该是 NULL（否则会形成环）
    temp2->next = NULL;
}
```

---

## 4、应用

### （1）括号匹配

- 从左到右扫描字符串
- 遇到开括号`(`, `[`, `{`就压入栈
- 遇到闭括号`)`, `]`, `}`就从栈中弹出一个开括号，检查是否匹配
- 最终栈应为空（即所有括号都正确匹配）

```F#
Check for balanced Parentheses(exp){
	n←length(exp)
	Create a stack S;
	for i from 0 to n-1{
		if (exp[i] is "(" or"[" or "{"){
			Push(exp[i])
			}else if(exp[i] is ")" or"]" or "}")
				if(S is empty){
					return false;
				}else{
					Pop()
				}
			}
			
	}
}
if S is empty true
else:  false
```

```C++
#include <string.h>
#include <stdbool.h>

bool CheckforParentheses(char* expression) {
    int n = strlen(expression);
    char S[100];
    int top = -1;// Stack to store the parentheses

    for (int i = 0; i < n; i++) {
        if (expression[i] == '(' ||
            expression[i] == '[' ||
            expression[i] == '{'    ) {
            S[++top] = expression[i];
            } else if (expression[i] == ')' ||
                       expression[i] == ']'||
                       expression[i]=='}') {
                if (top == -1) {
                    return false;
                } if (
                    (expression[i] == ')' && S[top] == '(') ||
                    (expression[i] == ']' && S[top] == '[') ||
                    (expression[i] == '}' && S[top] == '{')) {
                    top--;
                    }else {
                        return false;
                    }
                       }
    }
    return top==-1;//return true if all parentheses are matched
}

int main() {
    char expression[100];
    printf("Enter an expression: ");
    fgets(expression, sizeof(expression), stdin);
    expression[strcspn(expression, "\n")] = '\0'; //Remove \n from string
    CheckforParentheses(expression);
    if (CheckforParentheses(expression)) {
        printf(" The expression is valid\n");
    } else {
        printf("The expression is invalid\n");
    }
    return 0;
}
```

---

### （2）中缀转后缀

## 1）Intro

### ①Infix
![Infix.png](../assets/images/DataStruct/Infix.png)
### ②Prefix
![Prefix.png](../assets/images/DataStruct/Prefix.png)
### ③Postfix
![Postfix.png](../assets/images/DataStruct/Postfix.png)

---
![exFix.png](../assets/images/DataStruct/exFix.png)

---

## 2）Evaluation of  Prefix and Postfix expressions

![evaluate.png](../assets/images/DataStruct/evaluate.png)

!!! success
      >
      > Postfix：
      >
      > - Look for pattern `<num><num><operator>`(from left to right)
      >
      >   - ![RtoL.png](../assets/images/DataStruct/RtoL.png)
      >
      ```c++
      //Sudo code
      EvaluatePostfix(exp){
         create a stack S;
         for i to lenngth(exp)-1{
             if(exp[i] is operand){
                 Push(exp[i])
             }else if(exp[i] is operator){
                 op2 Pop;
                 op1 Pop;
                 res=Preform(exp[i],op1,op2);
                 Push(res)
             }
         }
         return top of stack
      }
      ```
      >
      > Prefix：
      >
      > - Look for pattern `<num><num><operator>`
      >   - Difference from Postfix: **scan from right to left**

---

## 3）Infix to Postfix

```c++
//Sudo code
InfixToPostfix(exp){
    create a stack s;
    res->empty string;
    for i from 0 to length (exp)-1{
        if exp[i] is operand {
            res<-res+exp[i];
        }
        else if exp[i] is operator{
            while(!=s.empty()&&HasHigherPrec(s.top(),exp[i])){
                res<-res+s.top();
                s.Pop()
            }
            s.Push(exp[i]);
        }
        while(!s.empty()){
            res<-res+s.top();
            s.pop();
        }
    }
    return res;
}
```

